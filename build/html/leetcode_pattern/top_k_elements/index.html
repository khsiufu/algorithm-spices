

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>13.1. Top ‘K’ Numbers (easy) &mdash; Algorithm Spices  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="14. K-way merge" href="../k-way_merge.html" />
    <link rel="prev" title="13. Top ‘K’ Elements" href="../top_k_elements.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> Algorithm Spices
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../preface.html">Learning Data</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">LeetCode Pattern</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../sliding_window.html">1. Sliding Window</a></li>
<li class="toctree-l2"><a class="reference internal" href="../two_points.html">2. Two Points</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fast_and_slow_pointers.html">3. Fast &amp; Slow pointers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../merge_intervals.html">4. Merge Intervals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cyclic_sort.html">5. Cyclic Sort</a></li>
<li class="toctree-l2"><a class="reference internal" href="../in-place_reversal_of_a_linkedlist.html">6. In-place Reversal of a LinkedList</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tree_breadth_first_search.html">7. Tree Breadth First Search</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tree_depth_first_search.html">8. Tree Depth First Search</a></li>
<li class="toctree-l2"><a class="reference internal" href="../two_heaps.html">9. Two Heaps</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsets.html">10. Subsets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modified_binary_search.html">11. Modified Binary Search</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bitwise_xor.html">12. Bitwise XOR</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../top_k_elements.html">13. Top ‘K’ Elements</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">13.1. Top ‘K’ Numbers (easy)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kth-smallest-number-easy">13.2. Kth Smallest Number (easy)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#k-closest-points-to-the-origin-easy">13.3. ‘K’ Closest Points to the Origin (easy)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#connect-ropes-easy">13.4. Connect Ropes (easy)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#top-k-frequent-numbers-medium">13.5. Top ‘K’ Frequent Numbers (medium)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#frequency-sort-medium">13.6. Frequency Sort (medium)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kth-largest-number-in-a-stream-medium">13.7. Kth Largest Number in a Stream (medium)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#k-closest-numbers-medium">13.8. ‘K’ Closest Numbers (medium)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#maximum-distinct-elements-medium">13.9. Maximum Distinct Elements (medium)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sum-of-elements-medium">13.10. Sum of Elements (medium)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rearrange-string-hard">13.11. Rearrange String (hard)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#problem-challenge-1-rearrange-string-k-distance-apart-hard">13.12. Problem Challenge 1 - Rearrange String K Distance Apart (hard)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#problem-challenge-2-scheduling-tasks-hard">13.13. Problem Challenge 2 - Scheduling Tasks (hard)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#problem-challenge-3-frequency-stack-hard">13.14. Problem Challenge 3 - Frequency Stack (hard)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../k-way_merge.html">14. K-way merge</a></li>
<li class="toctree-l2"><a class="reference internal" href="../0_1_knapsack_dynamic_programming.html">15. 0/1 Knapsack (Dynamic Programming)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../topological_sort_graph.html">16. Topological Sort (Graph)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../leetcode_tags/index.html">LeetCode Tags</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../leetcode_template/index.html">LeetCode Template</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Algorithm Spices</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">LeetCode Pattern</a> &raquo;</li>
        
          <li><a href="../top_k_elements.html"><span class="section-number">13. </span>Top ‘K’ Elements</a> &raquo;</li>
        
      <li><span class="section-number">13.1. </span>Top ‘K’ Numbers (easy)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/leetcode_pattern/top_k_elements/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="top-k-numbers-easy">
<h1><span class="section-number">13.1. </span>Top ‘K’ Numbers (easy)<a class="headerlink" href="#top-k-numbers-easy" title="Permalink to this headline">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Problem Statement</span>
<span class="sd">Given an unsorted array of numbers, find the ‘K’ largest numbers in it.</span>
<span class="sd">Note: For a detailed discussion about different approaches to solve this problem, take a look at Kth Smallest Number.</span>
<span class="sd">Example 1:</span>
<span class="sd">Input: [3, 1, 5, 12, 2, 11], K = 3</span>
<span class="sd">Output: [5, 12, 11]</span>
<span class="sd">Example 2:</span>
<span class="sd">Input: [5, 12, 11, -1, 12], K = 3</span>
<span class="sd">Output: [12, 11, 12]</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="c1"># mycode</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">def</span> <span class="nf">find_k_largest_numbers</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># TODO: Write your code here</span>

    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
            <span class="n">heappush</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">heappop</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="n">heappush</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Here are the top K numbers: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_k_largest_numbers</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span> <span class="mi">3</span><span class="p">)))</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Here are the top K numbers: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_k_largest_numbers</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="mi">3</span><span class="p">)))</span>


<span class="n">main</span><span class="p">()</span>

<span class="c1"># answer</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">def</span> <span class="nf">find_k_largest_numbers</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">minHeap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># put first &#39;K&#39; numbers in the min heap</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">minHeap</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># go through the remaining numbers of the array, if the number from the array is bigger than the</span>
    <span class="c1"># top(smallest) number of the min-heap, remove the top number from heap and add the number from array</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">minHeap</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">heappop</span><span class="p">(</span><span class="n">minHeap</span><span class="p">)</span>
            <span class="n">heappush</span><span class="p">(</span><span class="n">minHeap</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># the heap has the top &#39;K&#39; numbers, return them in a list</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">minHeap</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Here are the top K numbers: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_k_largest_numbers</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span> <span class="mi">3</span><span class="p">)))</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Here are the top K numbers: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_k_largest_numbers</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="mi">3</span><span class="p">)))</span>


<span class="n">main</span><span class="p">()</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Time complexity</span>
<span class="sd">As discussed above, the time complexity of this algorithm is O(K*logK+(N-K)*logK), which is asymptotically equal to O(N*logK)</span>
<span class="sd">Space complexity</span>
<span class="sd">The space complexity will be O(K) since we need to store the top ‘K’ numbers in the heap.</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="kth-smallest-number-easy">
<h1><span class="section-number">13.2. </span>Kth Smallest Number (easy)<a class="headerlink" href="#kth-smallest-number-easy" title="Permalink to this headline">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Problem Statement</span>
<span class="sd">Given an unsorted array of numbers, find Kth smallest number in it.</span>
<span class="sd">Please note that it is the Kth smallest number in the sorted order, not the Kth distinct element.</span>
<span class="sd">Note: For a detailed discussion about different approaches to solve this problem, take a look at Kth Smallest Number.</span>
<span class="sd">Example 1:</span>
<span class="sd">Input: [1, 5, 12, 2, 11, 5], K = 3</span>
<span class="sd">Output: 5</span>
<span class="sd">Explanation: The 3rd smallest number is &#39;5&#39;, as the first two smaller numbers are [1, 2].</span>
<span class="sd">Example 2:</span>
<span class="sd">Input: [1, 5, 12, 2, 11, 5], K = 4</span>
<span class="sd">Output: 5</span>
<span class="sd">Explanation: The 4th smallest number is &#39;5&#39;, as the first three small numbers are [1, 2, 5].</span>
<span class="sd">Example 3:</span>
<span class="sd">Input: [5, 12, 11, -1, 12], K = 3</span>
<span class="sd">Output: 11</span>
<span class="sd">Explanation: The 3rd smallest number is &#39;11&#39;, as the first two small numbers are [5, -1].</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="c1"># mycode</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">def</span> <span class="nf">find_Kth_smallest_number</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="c1"># TODO: Write your code here</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Kth smallest number is: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_Kth_smallest_number</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">)))</span>

    <span class="c1"># since there are two 5s in the input array, our 3rd and 4th smallest numbers should be a &#39;5&#39;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Kth smallest number is: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_Kth_smallest_number</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">)))</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Kth smallest number is: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_Kth_smallest_number</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="mi">3</span><span class="p">)))</span>


<span class="n">main</span><span class="p">()</span>

<span class="c1"># answer</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">def</span> <span class="nf">find_Kth_smallest_number</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">maxHeap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># put first k numbers in the max heap</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">maxHeap</span><span class="p">,</span> <span class="o">-</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># go through the remaining numbers of the array, if the number from the array is smaller than the</span>
    <span class="c1"># top(biggest) number of the heap, remove the top number from heap and add the number from array</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
        <span class="k">if</span> <span class="o">-</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">maxHeap</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">heappop</span><span class="p">(</span><span class="n">maxHeap</span><span class="p">)</span>
            <span class="n">heappush</span><span class="p">(</span><span class="n">maxHeap</span><span class="p">,</span> <span class="o">-</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># the root of the heap has the Kth smallest number</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">maxHeap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Kth smallest number is: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_Kth_smallest_number</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">)))</span>

    <span class="c1"># since there are two 5s in the input array, our 3rd and 4th smallest numbers should be a &#39;5&#39;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Kth smallest number is: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_Kth_smallest_number</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">)))</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Kth smallest number is: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_Kth_smallest_number</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="mi">3</span><span class="p">)))</span>


<span class="n">main</span><span class="p">()</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Time complexity</span>
<span class="sd">The time complexity of this algorithm is O(K*logK+(N-K)*logK), which is asymptotically equal to O(N*logK)</span>
<span class="sd">Space complexity</span>
<span class="sd">The space complexity will be O(K) because we need to store ‘K’ smallest numbers in the heap.</span>
<span class="sd">An Alternate Approach</span>
<span class="sd">Alternatively, we can use a Min Heap to find the Kth smallest number.</span>
<span class="sd">We can insert all the numbers in the min-heap and then extract the top ‘K’ numbers from the heap to find the Kth smallest number.</span>
<span class="sd">Initializing the min-heap with all numbers will take O(N) and extracting ‘K’ numbers will take O(KlogN).</span>
<span class="sd">Overall, the time complexity of this algorithm will be O(N+KlogN) and the space complexity will be O(N).</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="k-closest-points-to-the-origin-easy">
<h1><span class="section-number">13.3. </span>‘K’ Closest Points to the Origin (easy)<a class="headerlink" href="#k-closest-points-to-the-origin-easy" title="Permalink to this headline">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Problem Statement</span>
<span class="sd">Given an array of points in the a 2D2D plane, find ‘K’ closest points to the origin.</span>
<span class="sd">Example 1:</span>
<span class="sd">Input: points = [[1,2],[1,3]], K = 1</span>
<span class="sd">Output: [[1,2]]</span>
<span class="sd">Explanation: The Euclidean distance between (1, 2) and the origin is sqrt(5).</span>
<span class="sd">The Euclidean distance between (1, 3) and the origin is sqrt(10).</span>
<span class="sd">Since sqrt(5) &lt; sqrt(10), therefore (1, 2) is closer to the origin.</span>
<span class="sd">Example 2:</span>
<span class="sd">Input: point = [[1, 3], [3, 4], [2, -1]], K = 2</span>
<span class="sd">Output: [[1, 3], [2, -1]]</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>

    <span class="k">def</span> <span class="nf">print_point</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;] &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">find_closest_points</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># TODO: Write your code here</span>
    <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
            <span class="n">heappush</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">heappop</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="n">heappush</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">find_closest_points</span><span class="p">([</span><span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)],</span> <span class="mi">2</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Here are the k points closest the origin: &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
        <span class="n">point</span><span class="o">.</span><span class="n">print_point</span><span class="p">()</span>


<span class="n">main</span><span class="p">()</span>

<span class="c1"># answer</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>

    <span class="c1"># used for max-heap</span>
    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_from_origin</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">distance_from_origin</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">distance_from_origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># ignoring sqrt to calculate the distance</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">print_point</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;] &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">find_closest_points</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">maxHeap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># put first &#39;k&#39; points in the max heap</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">maxHeap</span><span class="p">,</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># go through the remaining points of the input array, if a point is closer to the origin than the top point</span>
    <span class="c1"># of the max-heap, remove the top point from heap and add the point from the input array</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">distance_from_origin</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">maxHeap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">distance_from_origin</span><span class="p">():</span>
            <span class="n">heappop</span><span class="p">(</span><span class="n">maxHeap</span><span class="p">)</span>
            <span class="n">heappush</span><span class="p">(</span><span class="n">maxHeap</span><span class="p">,</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># the heap has &#39;k&#39; points closest to the origin, return them in a list</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">maxHeap</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">find_closest_points</span><span class="p">([</span><span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)],</span> <span class="mi">2</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Here are the k points closest the origin: &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
        <span class="n">point</span><span class="o">.</span><span class="n">print_point</span><span class="p">()</span>


<span class="n">main</span><span class="p">()</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Time complexity</span>
<span class="sd">The time complexity of this algorithm is (N*logK) as we iterating all points and pushing them into the heap.</span>
<span class="sd">Space complexity</span>
<span class="sd">The space complexity will be O(K) because we need to store ‘K’ point in the heap.</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="connect-ropes-easy">
<h1><span class="section-number">13.4. </span>Connect Ropes (easy)<a class="headerlink" href="#connect-ropes-easy" title="Permalink to this headline">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Problem Statement</span>
<span class="sd">Given ‘N’ ropes with different lengths, we need to connect these ropes into one big rope with minimum cost.</span>
<span class="sd">The cost of connecting two ropes is equal to the sum of their lengths.</span>
<span class="sd">Example 1:</span>
<span class="sd">Input: [1, 3, 11, 5]</span>
<span class="sd">Output: 33</span>
<span class="sd">Explanation: First connect 1+3(=4), then 4+5(=9), and then 9+11(=20). So the total cost is 33 (4+9+20)</span>
<span class="sd">Example 2:</span>
<span class="sd">Input: [3, 4, 5, 6]</span>
<span class="sd">Output: 36</span>
<span class="sd">Explanation: First connect 3+4(=7), then 5+6(=11), 7+11(=18). Total cost is 36 (7+11+18)</span>
<span class="sd">Example 3:</span>
<span class="sd">Input: [1, 3, 11, 5, 2]</span>
<span class="sd">Output: 42</span>
<span class="sd">Explanation: First connect 1+2(=3), then 3+3(=6), 6+5(=11), 11+11(=22). Total cost is 42 (3+6+11+22)</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="c1"># mycode</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">def</span> <span class="nf">minimum_cost_to_connect_ropes</span><span class="p">(</span><span class="n">ropeLengths</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># TODO: Write your code here</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ropeLengths</span><span class="p">:</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="n">lenghth</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">+</span> <span class="n">heappop</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">lenghth</span> <span class="o">+=</span> <span class="n">temp</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lenghth</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Minimum cost to connect ropes: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">minimum_cost_to_connect_ropes</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">5</span><span class="p">])))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Minimum cost to connect ropes: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">minimum_cost_to_connect_ropes</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Minimum cost to connect ropes: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">minimum_cost_to_connect_ropes</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">])))</span>


<span class="n">main</span><span class="p">()</span>

<span class="c1"># answer</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">def</span> <span class="nf">minimum_cost_to_connect_ropes</span><span class="p">(</span><span class="n">ropeLengths</span><span class="p">):</span>
    <span class="n">minHeap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># add all ropes to the min heap</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ropeLengths</span><span class="p">:</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">minHeap</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="c1"># go through the values of the heap, in each step take top (lowest) rope lengths from the min heap</span>
    <span class="c1"># connect them and push the result back to the min heap.</span>
    <span class="c1"># keep doing this until the heap is left with only one rope</span>
    <span class="n">result</span><span class="p">,</span> <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">minHeap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">minHeap</span><span class="p">)</span> <span class="o">+</span> <span class="n">heappop</span><span class="p">(</span><span class="n">minHeap</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">temp</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">minHeap</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Minimum cost to connect ropes: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">minimum_cost_to_connect_ropes</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">5</span><span class="p">])))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Minimum cost to connect ropes: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">minimum_cost_to_connect_ropes</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Minimum cost to connect ropes: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">minimum_cost_to_connect_ropes</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">])))</span>


<span class="n">main</span><span class="p">()</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Time complexity</span>
<span class="sd">Given ‘N’ ropes, we need O(N*logN)to insert all the ropes in the heap.</span>
<span class="sd">In each step, while processing the heap, we take out two elements from the heap and insert one.</span>
<span class="sd">This means we will have a total of ‘N’ steps, having a total time complexity of O(N*logN).</span>
<span class="sd">Space complexity #</span>
<span class="sd">The space complexity will be O(N) because we need to store all the ropes in the heap.</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="top-k-frequent-numbers-medium">
<h1><span class="section-number">13.5. </span>Top ‘K’ Frequent Numbers (medium)<a class="headerlink" href="#top-k-frequent-numbers-medium" title="Permalink to this headline">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Problem Statement</span>
<span class="sd">Given an unsorted array of numbers, find the top ‘K’ frequently occurring numbers in it.</span>
<span class="sd">Example 1:</span>
<span class="sd">Input: [1, 3, 5, 12, 11, 12, 11], K = 2</span>
<span class="sd">Output: [12, 11]</span>
<span class="sd">Explanation: Both &#39;11&#39; and &#39;12&#39; apeared twice.</span>
<span class="sd">Example 2:</span>
<span class="sd">Input: [5, 12, 11, 3, 11], K = 2</span>
<span class="sd">Output: [11, 5] or [11, 12] or [11, 3]</span>
<span class="sd">Explanation: Only &#39;11&#39; appeared twice, all other numbers appeared once.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="c1"># mycode</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">def</span> <span class="nf">find_k_frequent_numbers</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">topNumbers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># TODO: Write your code here</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">:</span>
            <span class="n">mapping</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mapping</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
            <span class="n">heappush</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">num</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">freq</span> <span class="o">&gt;</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">heappop</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="n">heappush</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">num</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">topNumbers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">topNumbers</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Here are the K frequent numbers: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_k_frequent_numbers</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span> <span class="mi">2</span><span class="p">)))</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Here are the K frequent numbers: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_k_frequent_numbers</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span> <span class="mi">2</span><span class="p">)))</span>


<span class="n">main</span><span class="p">()</span>

<span class="c1"># answer</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">def</span> <span class="nf">find_k_frequent_numbers</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>

    <span class="c1"># find the frequency of each number</span>
    <span class="n">numFrequencyMap</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
        <span class="n">numFrequencyMap</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">numFrequencyMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">minHeap</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># go through all numbers of the numFrequencyMap and push them in the minHeap, which will have</span>
    <span class="c1"># top k frequent numbers. If the heap size is more than k, we remove the smallest(top) number</span>
    <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">frequency</span> <span class="ow">in</span> <span class="n">numFrequencyMap</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">minHeap</span><span class="p">,</span> <span class="p">(</span><span class="n">frequency</span><span class="p">,</span> <span class="n">num</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">minHeap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">:</span>
            <span class="n">heappop</span><span class="p">(</span><span class="n">minHeap</span><span class="p">)</span>

    <span class="c1"># create a list of top k numbers</span>
    <span class="n">topNumbers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">minHeap</span><span class="p">:</span>
        <span class="n">topNumbers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">heappop</span><span class="p">(</span><span class="n">minHeap</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">topNumbers</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Here are the K frequent numbers: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_k_frequent_numbers</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span> <span class="mi">2</span><span class="p">)))</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Here are the K frequent numbers: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_k_frequent_numbers</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span> <span class="mi">2</span><span class="p">)))</span>


<span class="n">main</span><span class="p">()</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Time complexity</span>
<span class="sd">The time complexity of the above algorithm is O(N+N*logK).</span>
<span class="sd">Space complexity</span>
<span class="sd">The space complexity will be O(N). Even though we are storing only ‘K’ numbers in the heap.</span>
<span class="sd">For the frequency map, however, we need to store all the ‘N’ numbers.</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="frequency-sort-medium">
<h1><span class="section-number">13.6. </span>Frequency Sort (medium)<a class="headerlink" href="#frequency-sort-medium" title="Permalink to this headline">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Problem Statement</span>
<span class="sd">Given a string, sort it based on the decreasing frequency of its characters.</span>
<span class="sd">Example 1:</span>
<span class="sd">Input: &quot;Programming&quot;</span>
<span class="sd">Output: &quot;rrggmmPiano&quot;</span>
<span class="sd">Explanation: &#39;r&#39;, &#39;g&#39;, and &#39;m&#39; appeared twice, so they need to appear before any other character.</span>
<span class="sd">Example 2:</span>
<span class="sd">Input: &quot;abcbab&quot;</span>
<span class="sd">Output: &quot;bbbaac&quot;</span>
<span class="sd">Explanation: &#39;b&#39; appeared three times, &#39;a&#39; appeared twice, and &#39;c&#39; appeared only once.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="c1"># mycode</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">def</span> <span class="nf">sort_character_by_frequency</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
    <span class="c1"># TODO: Write your code here</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">mapping</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">temp</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">freq</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>

    <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">while</span> <span class="n">temp</span><span class="p">:</span>
        <span class="n">freq</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">freq</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;String after sorting characters by frequency: &quot;</span> <span class="o">+</span>
          <span class="n">sort_character_by_frequency</span><span class="p">(</span><span class="s2">&quot;Programming&quot;</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;String after sorting characters by frequency: &quot;</span> <span class="o">+</span>
          <span class="n">sort_character_by_frequency</span><span class="p">(</span><span class="s2">&quot;abcbab&quot;</span><span class="p">))</span>


<span class="n">main</span><span class="p">()</span>

<span class="c1"># answer</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">def</span> <span class="nf">sort_character_by_frequency</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>

    <span class="c1"># find the frequency of each character</span>
    <span class="n">charFrequencyMap</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">charFrequencyMap</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="n">charFrequencyMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">maxHeap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># add all characters to the max heap</span>
    <span class="k">for</span> <span class="n">char</span><span class="p">,</span> <span class="n">frequency</span> <span class="ow">in</span> <span class="n">charFrequencyMap</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">maxHeap</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">frequency</span><span class="p">,</span> <span class="n">char</span><span class="p">))</span>

    <span class="c1"># build a string, appending the most occurring characters first</span>
    <span class="n">sortedString</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">maxHeap</span><span class="p">:</span>
        <span class="n">frequency</span><span class="p">,</span> <span class="n">char</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">maxHeap</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">frequency</span><span class="p">):</span>
            <span class="n">sortedString</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>

    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sortedString</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;String after sorting characters by frequency: &quot;</span> <span class="o">+</span>
          <span class="n">sort_character_by_frequency</span><span class="p">(</span><span class="s2">&quot;Programming&quot;</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;String after sorting characters by frequency: &quot;</span> <span class="o">+</span>
          <span class="n">sort_character_by_frequency</span><span class="p">(</span><span class="s2">&quot;abcbab&quot;</span><span class="p">))</span>


<span class="n">main</span><span class="p">()</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Time complexity</span>
<span class="sd">The time complexity of the above algorithm is O(D*logD) where ‘D’ is the number of distinct characters in the input string.</span>
<span class="sd">This means, in the worst case, when all characters are unique the time complexity of the algorithm will be O(N*logN)</span>
<span class="sd">where ‘N’ is the total number of characters in the string.</span>
<span class="sd">Space complexity</span>
<span class="sd">The space complexity will be O(N), as in the worst case, we need to store all the ‘N’ characters in the HashMap.</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="kth-largest-number-in-a-stream-medium">
<h1><span class="section-number">13.7. </span>Kth Largest Number in a Stream (medium)<a class="headerlink" href="#kth-largest-number-in-a-stream-medium" title="Permalink to this headline">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Problem Statement</span>
<span class="sd">Design a class to efficiently find the Kth largest element in a stream of numbers.</span>
<span class="sd">The class should have the following two things:</span>
<span class="sd">The constructor of the class should accept an integer array containing initial numbers from the stream and an integer ‘K’.</span>
<span class="sd">The class should expose a function add(int num) which will store the given number and return the Kth largest number.</span>
<span class="sd">Example 1:</span>
<span class="sd">Input: [3, 1, 5, 12, 2, 11], K = 4</span>
<span class="sd">1. Calling add(6) should return &#39;5&#39;.</span>
<span class="sd">2. Calling add(13) should return &#39;6&#39;.</span>
<span class="sd">2. Calling add(4) should still return &#39;6&#39;.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="c1"># mycode</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">class</span> <span class="nc">KthLargestNumberInStream</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="c1"># TODO: Write your code here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">:</span>
                <span class="n">heappop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="c1"># TODO: Write your code here</span>
        <span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">:</span>
            <span class="n">heappop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="n">kthLargestNumber</span> <span class="o">=</span> <span class="n">KthLargestNumberInStream</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span> <span class="mi">4</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;4th largest number is: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">kthLargestNumber</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">6</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;4th largest number is: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">kthLargestNumber</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">13</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;4th largest number is: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">kthLargestNumber</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span>


<span class="n">main</span><span class="p">()</span>

<span class="c1"># answer</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">class</span> <span class="nc">KthLargestNumberInStream</span><span class="p">:</span>
    <span class="n">minHeap</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>
        <span class="c1"># add the numbers in the min heap</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="c1"># add the new number in the min heap</span>
        <span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minHeap</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>

        <span class="c1"># if heap has more than &#39;k&#39; numbers, remove one number</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minHeap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">:</span>
            <span class="n">heappop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minHeap</span><span class="p">)</span>

        <span class="c1"># return the &#39;Kth largest number</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">minHeap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="n">kthLargestNumber</span> <span class="o">=</span> <span class="n">KthLargestNumberInStream</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span> <span class="mi">4</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;4th largest number is: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">kthLargestNumber</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">6</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;4th largest number is: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">kthLargestNumber</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">13</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;4th largest number is: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">kthLargestNumber</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span>


<span class="n">main</span><span class="p">()</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Time complexity</span>
<span class="sd">The time complexity of the add() function will be O(logK) since we are inserting the new number in the heap.</span>
<span class="sd">Space complexity</span>
<span class="sd">The space complexity will be O(K) for storing numbers in the heap.</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="k-closest-numbers-medium">
<h1><span class="section-number">13.8. </span>‘K’ Closest Numbers (medium)<a class="headerlink" href="#k-closest-numbers-medium" title="Permalink to this headline">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Problem Statement</span>
<span class="sd">Given a sorted number array and two integers ‘K’ and ‘X’, find ‘K’ closest numbers to ‘X’ in the array.</span>
<span class="sd">Return the numbers in the sorted order. ‘X’ is not necessarily present in the array.</span>
<span class="sd">Example 1:</span>
<span class="sd">Input: [5, 6, 7, 8, 9], K = 3, X = 7</span>
<span class="sd">Output: [6, 7, 8]</span>
<span class="sd">Example 2:</span>
<span class="sd">Input: [2, 4, 5, 6, 9], K = 3, X = 6</span>
<span class="sd">Output: [4, 5, 6]</span>
<span class="sd">Example 3:</span>
<span class="sd">Input: [2, 4, 5, 6, 9], K = 3, X = 10</span>
<span class="sd">Output: [5, 6, 9]</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="c1"># mycode</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">def</span> <span class="nf">find_closest_elements</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># TODO: Write your code here</span>
    <span class="n">temp1</span><span class="p">,</span> <span class="n">temp2</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">temp1</span><span class="p">,</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">i</span><span class="p">),</span> <span class="n">i</span><span class="p">))</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">K</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">temp2</span><span class="p">,</span> <span class="n">heappop</span><span class="p">(</span><span class="n">temp1</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="n">temp2</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">heappop</span><span class="p">(</span><span class="n">temp2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&#39;K&#39; closest numbers to &#39;X&#39; are: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_closest_elements</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&#39;K&#39; closest numbers to &#39;X&#39; are: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_closest_elements</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&#39;K&#39; closest numbers to &#39;X&#39; are: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_closest_elements</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)))</span>


<span class="n">main</span><span class="p">()</span>

<span class="c1"># answer</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">def</span> <span class="nf">find_closest_elements</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">binary_search</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
    <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">index</span> <span class="o">-</span> <span class="n">K</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="n">K</span>

    <span class="n">low</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># &#39;low&#39; should not be less than zero</span>
    <span class="c1"># &#39;high&#39; should not be greater the size of the array</span>
    <span class="n">high</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">high</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">minHeap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># add all candidate elements to the min heap, sorted by their absolute difference from &#39;X&#39;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">minHeap</span><span class="p">,</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">X</span><span class="p">),</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

    <span class="c1"># we need the top &#39;K&#39; elements having smallest difference from &#39;X&#39;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">heappop</span><span class="p">(</span><span class="n">minHeap</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">result</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mid</span>
        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">low</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">low</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">low</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&#39;K&#39; closest numbers to &#39;X&#39; are: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_closest_elements</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&#39;K&#39; closest numbers to &#39;X&#39; are: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_closest_elements</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&#39;K&#39; closest numbers to &#39;X&#39; are: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_closest_elements</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)))</span>


<span class="n">main</span><span class="p">()</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Time complexity</span>
<span class="sd">The time complexity of the above algorithm is O(logN + K*logK).</span>
<span class="sd">We need O(logN) for Binary Search and O(K*logK) to insert the numbers in the Min Heap,</span>
<span class="sd">as well as to sort the output array.</span>
<span class="sd">Space complexity</span>
<span class="sd">The space complexity will be O(K), as we need to put a maximum of 2K2K numbers in the heap.</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Alternate Solution using Two Pointers</span>
<span class="sd">After finding the number closest to ‘X’ through Binary Search,</span>
<span class="sd">we can use the Two Pointers approach to find the ‘K’ closest numbers.</span>
<span class="sd">Let’s say the closest number is ‘Y’.</span>
<span class="sd">We can have a left pointer to move back from ‘Y’ and a right pointer to move forward from ‘Y’.</span>
<span class="sd">At any stage, whichever number pointed out by the left or the right pointer gives the smaller difference from ‘X’</span>
<span class="sd">will be added to our result list.</span>
<span class="sd">To keep the resultant list sorted we can use a Queue.</span>
<span class="sd">So whenever we take the number pointed out by the left pointer,</span>
<span class="sd">we will append it at the beginning of the list and whenever we take the number pointed out by the right pointer</span>
<span class="sd">we will append it at the end of the list.</span>
<span class="sd">Here is what our algorithm will look like:</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>


<span class="k">def</span> <span class="nf">find_closest_elements</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">binary_search</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
    <span class="n">leftPointer</span><span class="p">,</span> <span class="n">rightPointer</span> <span class="o">=</span> <span class="n">index</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">leftPointer</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">rightPointer</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">diff1</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">arr</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">])</span>
            <span class="n">diff2</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">arr</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">diff1</span> <span class="o">&lt;=</span> <span class="n">diff2</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">])</span>
                <span class="n">leftPointer</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">])</span>
                <span class="n">rightPointer</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">leftPointer</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">])</span>
            <span class="n">leftPointer</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">rightPointer</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">])</span>
            <span class="n">rightPointer</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mid</span>
        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">low</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">low</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">low</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&#39;K&#39; closest numbers to &#39;X&#39; are: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_closest_elements</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&#39;K&#39; closest numbers to &#39;X&#39; are: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_closest_elements</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&#39;K&#39; closest numbers to &#39;X&#39; are: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_closest_elements</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)))</span>


<span class="n">main</span><span class="p">()</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Time complexity</span>
<span class="sd">The time complexity of the above algorithm is O(logN + K).</span>
<span class="sd">We need O(logN) for Binary Search and O(K) for finding the ‘K’ closest numbers using the two pointers.</span>
<span class="sd">Space complexity</span>
<span class="sd">If we ignoring the space required for the output list, the algorithm runs in constant space O(1).</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="maximum-distinct-elements-medium">
<h1><span class="section-number">13.9. </span>Maximum Distinct Elements (medium)<a class="headerlink" href="#maximum-distinct-elements-medium" title="Permalink to this headline">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Problem Statement</span>
<span class="sd">Given an array of numbers and a number ‘K’, we need to remove ‘K’ numbers from the array such that we are left with maximum distinct numbers.</span>
<span class="sd">Example 1:</span>
<span class="sd">Input: [7, 3, 5, 8, 5, 3, 3], and K=2</span>
<span class="sd">Output: 3</span>
<span class="sd">Explanation: We can remove two occurrences of 3 to be left with 3 distinct numbers [7, 3, 8], we have</span>
<span class="sd">to skip 5 because it is not distinct and occurred twice.</span>
<span class="sd">Another solution could be to remove one instance of &#39;5&#39; and &#39;3&#39; each to be left with three</span>
<span class="sd">distinct numbers [7, 5, 8], in this case, we have to skip 3 because it occurred twice.</span>
<span class="sd">Example 2:</span>
<span class="sd">Input: [3, 5, 12, 11, 12], and K=3</span>
<span class="sd">Output: 2</span>
<span class="sd">Explanation: We can remove one occurrence of 12, after which all numbers will become distinct. Then</span>
<span class="sd">we can delete any two numbers which will leave us 2 distinct numbers in the result.</span>
<span class="sd">Example 3:</span>
<span class="sd">Input: [1, 2, 3, 3, 3, 3, 4, 4, 5, 5, 5], and K=2</span>
<span class="sd">Output: 3</span>
<span class="sd">Explanation: We can remove one occurrence of &#39;4&#39; to get three distinct numbers.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="c1"># mycode</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">def</span> <span class="nf">find_maximum_distinct_elements</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="c1"># TODO: Write your code here</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
        <span class="n">mapping</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">heap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">freq</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">num</span><span class="p">))</span>

    <span class="k">while</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">heap</span><span class="p">:</span>
        <span class="n">freq</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">freq</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="n">freq</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="p">))</span>
        <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="n">count</span> <span class="o">-=</span> <span class="n">k</span>

    <span class="k">return</span> <span class="n">count</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Maximum distinct numbers after removing K numbers: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_maximum_distinct_elements</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Maximum distinct numbers after removing K numbers: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_maximum_distinct_elements</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="mi">3</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Maximum distinct numbers after removing K numbers: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
        <span class="n">find_maximum_distinct_elements</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">)))</span>


<span class="n">main</span><span class="p">()</span>

<span class="c1"># answer</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">def</span> <span class="nf">find_maximum_distinct_elements</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">distinctElementsCount</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">distinctElementsCount</span>

    <span class="c1"># find the frequency of each number</span>
    <span class="n">numFrequencyMap</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
        <span class="n">numFrequencyMap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numFrequencyMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">minHeap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># insert all numbers with frequency greater than &#39;1&#39; into the min-heap</span>
    <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">frequency</span> <span class="ow">in</span> <span class="n">numFrequencyMap</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">frequency</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">distinctElementsCount</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">heappush</span><span class="p">(</span><span class="n">minHeap</span><span class="p">,</span> <span class="p">(</span><span class="n">frequency</span><span class="p">,</span> <span class="n">num</span><span class="p">))</span>

    <span class="c1"># following a greedy approach, try removing the least frequent numbers first from the min-heap</span>
    <span class="k">while</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">minHeap</span><span class="p">:</span>
        <span class="n">frequency</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">minHeap</span><span class="p">)</span>
        <span class="c1"># to make an element distinct, we need to remove all of its occurrences except one</span>
        <span class="n">k</span> <span class="o">-=</span> <span class="n">frequency</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">distinctElementsCount</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># if k &gt; 0, this means we have to remove some distinct numbers</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">distinctElementsCount</span> <span class="o">-=</span> <span class="n">k</span>

    <span class="k">return</span> <span class="n">distinctElementsCount</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Maximum distinct numbers after removing K numbers: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_maximum_distinct_elements</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Maximum distinct numbers after removing K numbers: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_maximum_distinct_elements</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="mi">3</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Maximum distinct numbers after removing K numbers: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
        <span class="n">find_maximum_distinct_elements</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">)))</span>


<span class="n">main</span><span class="p">()</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Time complexity</span>
<span class="sd">Since we will insert all numbers in a HashMap and a Min Heap, this will take O(N*logN) where ‘N’ is the total input numbers.</span>
<span class="sd">While extracting numbers from the heap, in the worst case, we will need to take out ‘K’ numbers.</span>
<span class="sd">This will happen when we have at least ‘K’ numbers with a frequency of two.</span>
<span class="sd">Since the heap can have a maximum of ‘N/2’ numbers, therefore,</span>
<span class="sd">extracting an element from the heap will take O(logN) and extracting ‘K’ numbers will take O(KlogN).</span>
<span class="sd">So overall, the time complexity of our algorithm will be O(N*logN + KlogN).</span>
<span class="sd">We can optimize the above algorithm and only push ‘K’ elements in the heap,</span>
<span class="sd">as in the worst case we will be extracting ‘K’ elements from the heap. This optimization will reduce the overall time complexity to O(N*logK + KlogK).</span>
<span class="sd">Space complexity</span>
<span class="sd">The space complexity will be O(N) as, in the worst case, we need to store all the ‘N’ characters in the HashMap.</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="sum-of-elements-medium">
<h1><span class="section-number">13.10. </span>Sum of Elements (medium)<a class="headerlink" href="#sum-of-elements-medium" title="Permalink to this headline">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Problem Statement</span>
<span class="sd">Given an array, find the sum of all numbers between the K1’th and K2’th smallest elements of that array.</span>
<span class="sd">Example 1:</span>
<span class="sd">Input: [1, 3, 12, 5, 15, 11], and K1=3, K2=6</span>
<span class="sd">Output: 23</span>
<span class="sd">Explanation: The 3rd smallest number is 5 and 6th smallest number 15. The sum of numbers coming</span>
<span class="sd">between 5 and 15 is 23 (11+12).</span>
<span class="sd">Example 2:</span>
<span class="sd">Input: [3, 5, 8, 7], and K1=1, K2=4</span>
<span class="sd">Output: 12</span>
<span class="sd">Explanation: The sum of the numbers between the 1st smallest number (3) and the 4th smallest</span>
<span class="sd">number (8) is 12 (5+7).</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="c1"># mycode</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">def</span> <span class="nf">find_sum_of_elements</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">):</span>
    <span class="c1"># TODO: Write your code here</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>

    <span class="n">k</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">temp</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">k1</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">k2</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">num</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Sum of all numbers between k1 and k2 smallest numbers: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_sum_of_elements</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Sum of all numbers between k1 and k2 smallest numbers: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_sum_of_elements</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>


<span class="n">main</span><span class="p">()</span>

<span class="c1"># answer</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">def</span> <span class="nf">find_sum_of_elements</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">):</span>
    <span class="n">minHeap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># insert all numbers to the min heap</span>
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">minHeap</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>

    <span class="c1"># remove k1 small numbers from the min heap</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k1</span><span class="p">):</span>
        <span class="n">heappop</span><span class="p">(</span><span class="n">minHeap</span><span class="p">)</span>

    <span class="n">elementSum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># sum next k2-k1-1 numbers</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k2</span> <span class="o">-</span> <span class="n">k1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">elementSum</span> <span class="o">+=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">minHeap</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">elementSum</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Sum of all numbers between k1 and k2 smallest numbers: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_sum_of_elements</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Sum of all numbers between k1 and k2 smallest numbers: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_sum_of_elements</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>


<span class="n">main</span><span class="p">()</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Time complexity</span>
<span class="sd">Since we need to put all the numbers in a min-heap, the time complexity of the above algorithm will be O(N*logN)</span>
<span class="sd">where ‘N’ is the total input numbers.</span>
<span class="sd">Space complexity</span>
<span class="sd">The space complexity will be O(N), as we need to store all the ‘N’ numbers in the heap.</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Alternate Solution</span>
<span class="sd">We can iterate the array and use a max-heap to keep track of the top K2 numbers.</span>
<span class="sd">We can, then, add the top K2-K1-1 numbers in the max-heap to find the sum of all numbers</span>
<span class="sd">coming between the K1’th and K2’th smallest numbers. Here is what the algorithm will look like:</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">def</span> <span class="nf">find_sum_of_elements</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">):</span>
    <span class="n">maxHeap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># keep smallest k2 numbers in the max heap</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">heappush</span><span class="p">(</span><span class="n">maxHeap</span><span class="p">,</span> <span class="o">-</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">maxHeap</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">heappop</span><span class="p">(</span><span class="n">maxHeap</span>
                    <span class="p">)</span>  <span class="c1"># as we are interested only in the smallest k2 numbers</span>
            <span class="n">heappush</span><span class="p">(</span><span class="n">maxHeap</span><span class="p">,</span> <span class="o">-</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># get the sum of numbers between k1 and k2 indices</span>
    <span class="c1"># these numbers will be at the top of the max heap</span>
    <span class="n">elementSum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k2</span> <span class="o">-</span> <span class="n">k1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">elementSum</span> <span class="o">+=</span> <span class="o">-</span><span class="n">heappop</span><span class="p">(</span><span class="n">maxHeap</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">elementSum</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Sum of all numbers between k1 and k2 smallest numbers: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_sum_of_elements</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Sum of all numbers between k1 and k2 smallest numbers: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">find_sum_of_elements</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>


<span class="n">main</span><span class="p">()</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Time complexity</span>
<span class="sd">Since we need to put only the top K2 numbers in the max-heap at any time,</span>
<span class="sd">the time complexity of the above algorithm will be O(N*logK2).</span>
<span class="sd">Space complexity</span>
<span class="sd">The space complexity will be O(K2), as we need to store the smallest ‘K2’ numbers in the heap.</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="rearrange-string-hard">
<h1><span class="section-number">13.11. </span>Rearrange String (hard)<a class="headerlink" href="#rearrange-string-hard" title="Permalink to this headline">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Problem Statement</span>
<span class="sd">Given a string, find if its letters can be rearranged in such a way that no two same characters ome next to each other.</span>
<span class="sd">Example 1:</span>
<span class="sd">Input: &quot;aappp&quot;</span>
<span class="sd">Output: &quot;papap&quot;</span>
<span class="sd">Explanation: In &quot;papap&quot;, none of the repeating characters come next to each other.</span>
<span class="sd">Example 2:</span>
<span class="sd">Input: &quot;Programming&quot;</span>
<span class="sd">Output: &quot;rgmrgmPiano&quot; or &quot;gmringmrPoa&quot; or &quot;gmrPagimnor&quot;, etc.</span>
<span class="sd">Explanation: None of the repeating characters come next to each other.</span>
<span class="sd">Example 3:</span>
<span class="sd">Input: &quot;aapa&quot;</span>
<span class="sd">Output: &quot;&quot;</span>
<span class="sd">Explanation: In all arrangements of &quot;aapa&quot;, atleast two &#39;a&#39; will come together e.g., &quot;apaa&quot;, &quot;paaa&quot;.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="c1"># mycode</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">def</span> <span class="nf">rearrange_string</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
    <span class="c1"># TODO: Write your code here</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">mapping</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">heap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">freq</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>

    <span class="n">result</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">while</span> <span class="n">heap</span><span class="p">:</span>
        <span class="n">most_freq</span><span class="p">,</span> <span class="n">most_i</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">most_i</span>
        <span class="k">if</span> <span class="o">-</span><span class="n">most_freq</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="n">most_freq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">most_i</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">heap</span><span class="p">:</span>
            <span class="n">sec_freq</span><span class="p">,</span> <span class="n">sec_i</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sec_i</span> <span class="o">==</span> <span class="n">most_i</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="n">sec_freq</span><span class="p">,</span> <span class="n">sec_i</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Rearranged string:  &quot;</span> <span class="o">+</span> <span class="n">rearrange_string</span><span class="p">(</span><span class="s2">&quot;aappp&quot;</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Rearranged string:  &quot;</span> <span class="o">+</span> <span class="n">rearrange_string</span><span class="p">(</span><span class="s2">&quot;Programming&quot;</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Rearranged string:  &quot;</span> <span class="o">+</span> <span class="n">rearrange_string</span><span class="p">(</span><span class="s2">&quot;aapa&quot;</span><span class="p">))</span>


<span class="n">main</span><span class="p">()</span>

<span class="c1"># answer</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">def</span> <span class="nf">rearrange_string</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
    <span class="n">charFrequencyMap</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">charFrequencyMap</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="n">charFrequencyMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">maxHeap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># add all characters to the max heap</span>
    <span class="k">for</span> <span class="n">char</span><span class="p">,</span> <span class="n">frequency</span> <span class="ow">in</span> <span class="n">charFrequencyMap</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">maxHeap</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">frequency</span><span class="p">,</span> <span class="n">char</span><span class="p">))</span>

    <span class="n">previousChar</span><span class="p">,</span> <span class="n">previousFrequency</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span>
    <span class="n">resultString</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">maxHeap</span><span class="p">:</span>
        <span class="n">frequency</span><span class="p">,</span> <span class="n">char</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">maxHeap</span><span class="p">)</span>
        <span class="c1"># add the previous entry back in the heap if its frequency is greater than zero</span>
        <span class="k">if</span> <span class="n">previousChar</span> <span class="ow">and</span> <span class="o">-</span><span class="n">previousFrequency</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">heappush</span><span class="p">(</span><span class="n">maxHeap</span><span class="p">,</span> <span class="p">(</span><span class="n">previousFrequency</span><span class="p">,</span> <span class="n">previousChar</span><span class="p">))</span>
        <span class="c1"># append the current character to the result string and decrement its count</span>
        <span class="n">resultString</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
        <span class="n">previousChar</span> <span class="o">=</span> <span class="n">char</span>
        <span class="n">previousFrequency</span> <span class="o">=</span> <span class="n">frequency</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># decrement the frequency</span>

    <span class="c1"># if we were successful in appending all the characters to the result string, return it</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">resultString</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">resultString</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Rearranged string:  &quot;</span> <span class="o">+</span> <span class="n">rearrange_string</span><span class="p">(</span><span class="s2">&quot;aappp&quot;</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Rearranged string:  &quot;</span> <span class="o">+</span> <span class="n">rearrange_string</span><span class="p">(</span><span class="s2">&quot;Programming&quot;</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Rearranged string:  &quot;</span> <span class="o">+</span> <span class="n">rearrange_string</span><span class="p">(</span><span class="s2">&quot;aapa&quot;</span><span class="p">))</span>


<span class="n">main</span><span class="p">()</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Time complexity</span>
<span class="sd">The time complexity of the above algorithm is O(N*logN) where ‘N’ is the number of characters in the input string.</span>
<span class="sd">Space complexity</span>
<span class="sd">The space complexity will be O(N), as in the worst case, we need to store all the ‘N’ characters in the HashMap.</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="problem-challenge-1-rearrange-string-k-distance-apart-hard">
<h1><span class="section-number">13.12. </span>Problem Challenge 1 - Rearrange String K Distance Apart (hard)<a class="headerlink" href="#problem-challenge-1-rearrange-string-k-distance-apart-hard" title="Permalink to this headline">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Problem Challenge 1</span>
<span class="sd">Rearrange String K Distance Apart (hard)</span>
<span class="sd">Given a string and a number ‘K’, find if the string can be rearranged such that the same characters are at least ‘K’ distance apart from each other.</span>
<span class="sd">Example 1:</span>
<span class="sd">Input: &quot;mmpp&quot;, K=2</span>
<span class="sd">Output: &quot;mpmp&quot; or &quot;pmpm&quot;</span>
<span class="sd">Explanation: All same characters are 2 distance apart.</span>
<span class="sd">Example 2:</span>
<span class="sd">Input: &quot;Programming&quot;, K=3</span>
<span class="sd">Output: &quot;rgmPrgmiano&quot; or &quot;gmringmrPoa&quot; or &quot;gmrPagimnor&quot; and a few more</span>
<span class="sd">Explanation: All same characters are 3 distance apart.</span>
<span class="sd">Example 3:</span>
<span class="sd">Input: &quot;aab&quot;, K=2</span>
<span class="sd">Output: &quot;aba&quot;</span>
<span class="sd">Explanation: All same characters are 2 distance apart.</span>
<span class="sd">Example 4:</span>
<span class="sd">Input: &quot;aappa&quot;, K=3</span>
<span class="sd">Output: &quot;&quot;</span>
<span class="sd">Explanation: We cannot find an arrangement of the string where any two &#39;a&#39; are 3 distance apart.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>


<span class="k">def</span> <span class="nf">reorganize_string</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="c1"># TODO: Write your code here</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">mapping</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">heap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">freq</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>

    <span class="n">result</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

    <span class="k">while</span> <span class="n">heap</span><span class="p">:</span>
        <span class="n">freq</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">i</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">freq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">:</span>
            <span class="n">freq</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="o">-</span><span class="n">freq</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">result</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Reorganized string: &quot;</span> <span class="o">+</span> <span class="n">reorganize_string</span><span class="p">(</span><span class="s2">&quot;mmpp&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Reorganized string: &quot;</span> <span class="o">+</span> <span class="n">reorganize_string</span><span class="p">(</span><span class="s2">&quot;Programming&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Reorganized string: &quot;</span> <span class="o">+</span> <span class="n">reorganize_string</span><span class="p">(</span><span class="s2">&quot;aab&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Reorganized string: &quot;</span> <span class="o">+</span> <span class="n">reorganize_string</span><span class="p">(</span><span class="s2">&quot;aapa&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>


<span class="n">main</span><span class="p">()</span>

<span class="c1"># answer</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>


<span class="k">def</span> <span class="nf">reorganize_string</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span>

    <span class="n">charFrequencyMap</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">charFrequencyMap</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="n">charFrequencyMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">maxHeap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># add all characters to the max heap</span>
    <span class="k">for</span> <span class="n">char</span><span class="p">,</span> <span class="n">frequency</span> <span class="ow">in</span> <span class="n">charFrequencyMap</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">maxHeap</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">frequency</span><span class="p">,</span> <span class="n">char</span><span class="p">))</span>

    <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
    <span class="n">resultString</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">maxHeap</span><span class="p">:</span>
        <span class="n">frequency</span><span class="p">,</span> <span class="n">char</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">maxHeap</span><span class="p">)</span>
        <span class="c1"># append the current character to the result string and decrement its count</span>
        <span class="n">resultString</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
        <span class="c1"># decrement the frequency and append to the queue</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">char</span><span class="p">,</span> <span class="n">frequency</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
            <span class="n">char</span><span class="p">,</span> <span class="n">frequency</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="o">-</span><span class="n">frequency</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">heappush</span><span class="p">(</span><span class="n">maxHeap</span><span class="p">,</span> <span class="p">(</span><span class="n">frequency</span><span class="p">,</span> <span class="n">char</span><span class="p">))</span>

    <span class="c1"># if we were successful in appending all the characters to the result string, return it</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">resultString</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">resultString</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Reorganized string: &quot;</span> <span class="o">+</span> <span class="n">reorganize_string</span><span class="p">(</span><span class="s2">&quot;Programming&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Reorganized string: &quot;</span> <span class="o">+</span> <span class="n">reorganize_string</span><span class="p">(</span><span class="s2">&quot;mmpp&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Reorganized string: &quot;</span> <span class="o">+</span> <span class="n">reorganize_string</span><span class="p">(</span><span class="s2">&quot;aab&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Reorganized string: &quot;</span> <span class="o">+</span> <span class="n">reorganize_string</span><span class="p">(</span><span class="s2">&quot;aapa&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>


<span class="n">main</span><span class="p">()</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Time complexity</span>
<span class="sd">The time complexity of the above algorithm is O(N*logN) where ‘N’ is the number of characters in the input string.</span>
<span class="sd">Space complexity</span>
<span class="sd">The space complexity will be O(N), as in the worst case, we need to store all the ‘N’ characters in the HashMap.</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="problem-challenge-2-scheduling-tasks-hard">
<h1><span class="section-number">13.13. </span>Problem Challenge 2 - Scheduling Tasks (hard)<a class="headerlink" href="#problem-challenge-2-scheduling-tasks-hard" title="Permalink to this headline">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Problem Challenge 2</span>
<span class="sd">Scheduling Tasks (hard)</span>
<span class="sd">You are given a list of tasks that need to be run, in any order, on a server. Each task will take one CPU interval to execute but once a task has finished, it has a cooling period during which it can’t be run again. If the cooling period for all tasks is ‘K’ intervals, find the minimum number of CPU intervals that the server needs to finish all tasks.</span>
<span class="sd">If at any time the server can’t execute any task then it must stay idle.</span>
<span class="sd">Example 1:</span>
<span class="sd">Input: [a, a, a, b, c, c], K=2</span>
<span class="sd">Output: 7</span>
<span class="sd">Explanation: a -&gt; c -&gt; b -&gt; a -&gt; c -&gt; idle -&gt; a</span>
<span class="sd">Example 2:</span>
<span class="sd">Input: [a, b, a], K=3</span>
<span class="sd">Output: 5</span>
<span class="sd">Explanation: a -&gt; b -&gt; idle -&gt; idle -&gt; a</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="c1"># mycode</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>


<span class="k">def</span> <span class="nf">schedule_tasks</span><span class="p">(</span><span class="n">tasks</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">intervalCount</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># TODO: Write your code here</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tasks</span><span class="p">:</span>
        <span class="n">mapping</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">heap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">freq</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>

    <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
    <span class="n">char</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">while</span> <span class="n">heap</span><span class="p">:</span>
        <span class="n">freq</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>

        <span class="n">intervalCount</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">char</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">len_queue</span><span class="p">)</span>
            <span class="n">intervalCount</span> <span class="o">+=</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">len_queue</span><span class="p">)</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">freq</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">:</span>
            <span class="n">freq</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="o">-</span><span class="n">freq</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">char</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="n">freq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">heap</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">and</span> <span class="n">queue</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="n">freq</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="o">-</span><span class="n">freq</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">char</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="n">freq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>

        <span class="n">len_queue</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">intervalCount</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Minimum intervals needed to execute all tasks: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">schedule_tasks</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Minimum intervals needed to execute all tasks: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">schedule_tasks</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">)))</span>


<span class="n">main</span><span class="p">()</span>

<span class="c1"># answer</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">def</span> <span class="nf">schedule_tasks</span><span class="p">(</span><span class="n">tasks</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">intervalCount</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">taskFrequencyMap</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">tasks</span><span class="p">:</span>
        <span class="n">taskFrequencyMap</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="n">taskFrequencyMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">maxHeap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># add all tasks to the max heap</span>
    <span class="k">for</span> <span class="n">char</span><span class="p">,</span> <span class="n">frequency</span> <span class="ow">in</span> <span class="n">taskFrequencyMap</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">maxHeap</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">frequency</span><span class="p">,</span> <span class="n">char</span><span class="p">))</span>

    <span class="k">while</span> <span class="n">maxHeap</span><span class="p">:</span>
        <span class="n">waitList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># try to execute as many as &#39;k+1&#39; tasks from the max-heap</span>
        <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">maxHeap</span><span class="p">:</span>
            <span class="n">intervalCount</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">frequency</span><span class="p">,</span> <span class="n">char</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">maxHeap</span><span class="p">)</span>
            <span class="k">if</span> <span class="o">-</span><span class="n">frequency</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># decrement the frequency and add to the waitList</span>
                <span class="n">waitList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">frequency</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">char</span><span class="p">))</span>
            <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="c1"># put all the waiting list back on the heap</span>
        <span class="k">for</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">waitList</span><span class="p">:</span>
            <span class="n">heappush</span><span class="p">(</span><span class="n">maxHeap</span><span class="p">,</span> <span class="p">(</span><span class="n">frequency</span><span class="p">,</span> <span class="n">char</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">maxHeap</span><span class="p">:</span>
            <span class="n">intervalCount</span> <span class="o">+=</span> <span class="n">n</span>  <span class="c1"># we&#39;ll be having &#39;n&#39; idle intervals for the next iteration</span>

    <span class="k">return</span> <span class="n">intervalCount</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Minimum intervals needed to execute all tasks: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">schedule_tasks</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Minimum intervals needed to execute all tasks: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">schedule_tasks</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">)))</span>


<span class="n">main</span><span class="p">()</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Time complexity</span>
<span class="sd">The time complexity of the above algorithm is O(N*logN) where ‘N’ is the number of tasks.</span>
<span class="sd">Our while loop will iterate once for each occurrence of the task in the input (i.e. ‘N’) and</span>
<span class="sd">in each iteration we will remove a task from the heap which will take O(logN) time.</span>
<span class="sd">Hence the overall time complexity of our algorithm is O(N*logN).</span>
<span class="sd">Space complexity</span>
<span class="sd">The space complexity will be O(N), as in the worst case, we need to store all the ‘N’ tasks in the HashMap.</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="problem-challenge-3-frequency-stack-hard">
<h1><span class="section-number">13.14. </span>Problem Challenge 3 - Frequency Stack (hard)<a class="headerlink" href="#problem-challenge-3-frequency-stack-hard" title="Permalink to this headline">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Problem Challenge 3</span>
<span class="sd">Frequency Stack (hard)</span>
<span class="sd">Design a class that simulates a Stack data structure, implementing the following two operations:</span>
<span class="sd">push(int num): Pushes the number ‘num’ on the stack.</span>
<span class="sd">pop(): Returns the most frequent number in the stack. If there is a tie, return the number which was pushed later.</span>
<span class="sd">Example:</span>
<span class="sd">After following push operations: push(1), push(2), push(3), push(2), push(1), push(2), push(5)</span>

<span class="sd">1. pop() should return 2, as it is the most frequent number</span>
<span class="sd">2. Next pop() should return 1</span>
<span class="sd">3. Next pop() should return 2</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="c1"># mycode</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">class</span> <span class="nc">FrequencyStack</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">heap</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="c1"># TODO: Write your code here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">num</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">heap</span><span class="p">:</span>
            <span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">[</span><span class="n">num</span><span class="p">],</span> <span class="n">num</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">heap</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">heap</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">heap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">heap</span><span class="p">[:</span><span class="n">index</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">heap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">index</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">heap</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
            <span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">mapping</span><span class="p">[</span><span class="n">num</span><span class="p">],</span> <span class="n">num</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">freq</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">heap</span><span class="p">)</span>
        <span class="k">if</span> <span class="o">-</span><span class="n">freq</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">freq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">i</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">frequencyStack</span> <span class="o">=</span> <span class="n">FrequencyStack</span><span class="p">()</span>
    <span class="n">frequencyStack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">frequencyStack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">frequencyStack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">frequencyStack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">frequencyStack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">frequencyStack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">frequencyStack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">frequencyStack</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">frequencyStack</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">frequencyStack</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>


<span class="n">main</span><span class="p">()</span>

<span class="c1"># answer</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="o">*</span>


<span class="k">class</span> <span class="nc">Element</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">sequenceNumber</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">number</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frequency</span> <span class="o">=</span> <span class="n">frequency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sequenceNumber</span> <span class="o">=</span> <span class="n">sequenceNumber</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># higher frequency wins</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">frequency</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">frequency</span>
        <span class="c1"># if both elements have same frequency, return the element that was pushed later</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequenceNumber</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">sequenceNumber</span>


<span class="k">class</span> <span class="nc">FrequencyStack</span><span class="p">:</span>
    <span class="n">sequenceNumber</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">maxHeap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">frequencyMap</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frequencyMap</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequencyMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxHeap</span><span class="p">,</span>
                 <span class="n">Element</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequencyMap</span><span class="p">[</span><span class="n">num</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequenceNumber</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sequenceNumber</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxHeap</span><span class="p">)</span><span class="o">.</span><span class="n">number</span>
        <span class="c1"># decrement the frequency or remove if this is the last number</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequencyMap</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frequencyMap</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequencyMap</span><span class="p">[</span><span class="n">num</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">num</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">frequencyStack</span> <span class="o">=</span> <span class="n">FrequencyStack</span><span class="p">()</span>
    <span class="n">frequencyStack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">frequencyStack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">frequencyStack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">frequencyStack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">frequencyStack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">frequencyStack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">frequencyStack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">frequencyStack</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">frequencyStack</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">frequencyStack</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>


<span class="n">main</span><span class="p">()</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Time complexity</span>
<span class="sd">The time complexity of push() and pop() is O(logN) where ‘N’ is the current number of elements in the heap.</span>
<span class="sd">Space complexity</span>
<span class="sd">We will need O(N) space for the heap and the map, so the overall space complexity of the algorithm is O(N).</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../k-way_merge.html" class="btn btn-neutral float-right" title="14. K-way merge" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../top_k_elements.html" class="btn btn-neutral float-left" title="13. Top ‘K’ Elements" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, XiuFu Guo

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>