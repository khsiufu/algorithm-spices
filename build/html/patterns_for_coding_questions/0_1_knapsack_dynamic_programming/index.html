

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>15.1. 0/1 Knapsack (medium) &mdash; Algorithm Spices  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="16. Topological Sort (Graph)" href="../topological_sort_graph.html" />
    <link rel="prev" title="15. 0/1 Knapsack (Dynamic Programming)" href="../0_1_knapsack_dynamic_programming.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> Algorithm Spices
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../preface.html">Preface</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Patterns for Coding Questions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../sliding_window.html">1. Sliding Window</a></li>
<li class="toctree-l2"><a class="reference internal" href="../two_points.html">2. Two Points</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fast_and_slow_pointers.html">3. Fast &amp; Slow pointers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../merge_intervals.html">4. Merge Intervals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cyclic_sort.html">5. Cyclic Sort</a></li>
<li class="toctree-l2"><a class="reference internal" href="../in-place_reversal_of_a_linkedlist.html">6. In-place Reversal of a LinkedList</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tree_breadth_first_search.html">7. Tree Breadth First Search</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tree_depth_first_search.html">8. Tree Depth First Search</a></li>
<li class="toctree-l2"><a class="reference internal" href="../two_heaps.html">9. Two Heaps</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsets.html">10. Subsets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modified_binary_search.html">11. Modified Binary Search</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bitwise_xor.html">12. Bitwise XOR</a></li>
<li class="toctree-l2"><a class="reference internal" href="../top_k_elements.html">13. Top ‘K’ Elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../k-way_merge.html">14. K-way merge</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../0_1_knapsack_dynamic_programming.html">15. 0/1 Knapsack (Dynamic Programming)</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">15.1. 0/1 Knapsack (medium)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#equal-subset-sum-partition-medium">15.2. Equal Subset Sum Partition (medium)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#subset-sum-medium">15.3. Subset Sum (medium)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#minimum-subset-sum-difference-hard">15.4. Minimum Subset Sum Difference (hard)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#problem-challenge-1-count-of-subset-sum-hard">15.5. Problem Challenge 1 - Count of Subset Sum (hard)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#problem-challenge-2-target-sum-hard">15.6. Problem Challenge 2 - Target Sum (hard)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../topological_sort_graph.html">16. Topological Sort (Graph)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">17. Miscellaneous</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../leetcode_tags/index.html">LeetCode Tags</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../leetcode_template/index.html">LeetCode Template</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Algorithm Spices</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Patterns for Coding Questions</a> &raquo;</li>
        
          <li><a href="../0_1_knapsack_dynamic_programming.html"><span class="section-number">15. </span>0/1 Knapsack (Dynamic Programming)</a> &raquo;</li>
        
      <li><span class="section-number">15.1. </span>0/1 Knapsack (medium)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/patterns_for_coding_questions/0_1_knapsack_dynamic_programming/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="knapsack-medium">
<h1><span class="section-number">15.1. </span>0/1 Knapsack (medium)<a class="headerlink" href="#knapsack-medium" title="Permalink to this headline">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Introduction</span>
<span class="sd">Given the weights and profits of ‘N’ items, we are asked to put these items in a knapsack which has a capacity ‘C’.</span>
<span class="sd">The goal is to get the maximum profit out of the items in the knapsack.</span>
<span class="sd">Each item can only be selected once, as we don’t have multiple quantities of any item.</span>
<span class="sd">Let’s take the example of Merry, who wants to carry some fruits in the knapsack to get maximum profit.</span>
<span class="sd">    Here are the weights and profits of the fruits:</span>
<span class="sd">Items: { Apple, Orange, Banana, Melon }</span>
<span class="sd">Weights: { 2, 3, 1, 4 }</span>
<span class="sd">Profits: { 4, 5, 3, 7 }</span>
<span class="sd">Knapsack capacity: 5</span>
<span class="sd">Let’s try to put various combinations of fruits in the knapsack, such that their total weight is not more than 5:</span>
<span class="sd">Apple + Orange (total weight 5) =&gt; 9 profit</span>
<span class="sd">Apple + Banana (total weight 3) =&gt; 7 profit</span>
<span class="sd">Orange + Banana (total weight 4) =&gt; 8 profit</span>
<span class="sd">Banana + Melon (total weight 5) =&gt; 10 profit</span>
<span class="sd">This shows that Banana + Melon is the best combination as it gives us the maximum profit and the total weight does not exceed the capacity.</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="c1"># Basic Solution</span>
<span class="k">def</span> <span class="nf">solve_knapsack</span><span class="p">(</span><span class="n">profits</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">capacity</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">knapsack_recursive</span><span class="p">(</span><span class="n">profits</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">knapsack_recursive</span><span class="p">(</span><span class="n">profits</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">currentIndex</span><span class="p">):</span>
    <span class="c1"># base checks</span>
    <span class="k">if</span> <span class="n">capacity</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">currentIndex</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">profits</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="c1"># recursive call after choosing the element at the currentIndex</span>
    <span class="c1"># if the weight of the element at currentIndex exceeds the capacity, we  shouldn&#39;t process this</span>
    <span class="n">profit1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">weights</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">capacity</span><span class="p">:</span>
        <span class="n">profit1</span> <span class="o">=</span> <span class="n">profits</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">]</span> <span class="o">+</span> <span class="n">knapsack_recursive</span><span class="p">(</span>
            <span class="n">profits</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">capacity</span> <span class="o">-</span> <span class="n">weights</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">],</span>
            <span class="n">currentIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># recursive call after excluding the element at the currentIndex</span>
    <span class="n">profit2</span> <span class="o">=</span> <span class="n">knapsack_recursive</span><span class="p">(</span><span class="n">profits</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">currentIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">profit1</span><span class="p">,</span> <span class="n">profit2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">solve_knapsack</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">16</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">7</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">solve_knapsack</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">16</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">6</span><span class="p">))</span>


<span class="n">main</span><span class="p">()</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Time and Space complexity</span>
<span class="sd">The time complexity of the above algorithm is exponential O(2^n),</span>
<span class="sd">where ‘n’ represents the total number of items. This can also be confirmed from the above recursion tree.</span>
<span class="sd">As we can see, we will have a total of ‘31’ recursive calls – calculated through (2^n) + (2^n) - 1,</span>
<span class="sd">which is asymptotically equivalent to O(2^n).</span>
<span class="sd">The space complexity is O(n). This space will be used to store the recursion stack.</span>
<span class="sd">Since the recursive algorithm works in a depth-first fashion,</span>
<span class="sd">which means that we can’t have more than ‘n’ recursive calls on the call stack at any time.</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="c1"># Top-down Dynamic Programming with Memoization</span>
<span class="k">def</span> <span class="nf">solve_knapsack</span><span class="p">(</span><span class="n">profits</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">capacity</span><span class="p">):</span>
    <span class="c1"># create a two dimensional array for Memoization, each element is initialized to &#39;-1&#39;</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">capacity</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">profits</span><span class="p">))]</span>
    <span class="k">return</span> <span class="n">knapsack_recursive</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">profits</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">knapsack_recursive</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">profits</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">currentIndex</span><span class="p">):</span>

    <span class="c1"># base checks</span>
    <span class="k">if</span> <span class="n">capacity</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">currentIndex</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">profits</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="c1"># if we have already solved a similar problem, return the result from memory</span>
    <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">][</span><span class="n">capacity</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">][</span><span class="n">capacity</span><span class="p">]</span>

    <span class="c1"># recursive call after choosing the element at the currentIndex</span>
    <span class="c1"># if the weight of the element at currentIndex exceeds the capacity, we</span>
    <span class="c1"># shouldn&#39;t process this</span>
    <span class="n">profit1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">weights</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">capacity</span><span class="p">:</span>
        <span class="n">profit1</span> <span class="o">=</span> <span class="n">profits</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">]</span> <span class="o">+</span> <span class="n">knapsack_recursive</span><span class="p">(</span>
            <span class="n">dp</span><span class="p">,</span> <span class="n">profits</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">capacity</span> <span class="o">-</span> <span class="n">weights</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">],</span>
            <span class="n">currentIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># recursive call after excluding the element at the currentIndex</span>
    <span class="n">profit2</span> <span class="o">=</span> <span class="n">knapsack_recursive</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">profits</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span>
                                 <span class="n">currentIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">dp</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">][</span><span class="n">capacity</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">profit1</span><span class="p">,</span> <span class="n">profit2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">][</span><span class="n">capacity</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">solve_knapsack</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">16</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">7</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">solve_knapsack</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">16</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">6</span><span class="p">))</span>


<span class="n">main</span><span class="p">()</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Time and Space complexity</span>
<span class="sd">Since our memorization array dp[profits.length][capacity+1] stores the results for all subproblems,</span>
<span class="sd">we can conclude that we will not have more than N*C subproblems (where ‘N’ is the number of items and ‘C’ is the knapsack capacity).</span>
<span class="sd">This means that our time complexity will be O(N*C).</span>
<span class="sd">The above algorithm will use O(N*C) space for the memorization array.</span>
<span class="sd">Other than that we will use O(N) space for the recursion call-stack.</span>
<span class="sd">So the total space complexity will be O(N*C + N), which is asymptotically equivalent to O(N*C).</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="c1"># Bottom-up Dynamic Programming</span>
<span class="k">def</span> <span class="nf">solve_knapsack</span><span class="p">(</span><span class="n">profits</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">capacity</span><span class="p">):</span>
    <span class="c1"># basic checks</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">profits</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">capacity</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">capacity</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="c1"># populate the capacity = 0 columns, with &#39;0&#39; capacity we have &#39;0&#39; profit</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># if we have only one weight, we will take it if it is not more than the capacity</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">capacity</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="p">:</span>
            <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">profits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># process all sub-arrays for all the capacities</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">capacity</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">profit1</span><span class="p">,</span> <span class="n">profit2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
            <span class="c1"># include the item, if it is not more than the capacity</span>
            <span class="k">if</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="p">:</span>
                <span class="n">profit1</span> <span class="o">=</span> <span class="n">profits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">c</span> <span class="o">-</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="c1"># exclude the item</span>
            <span class="n">profit2</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">c</span><span class="p">]</span>
            <span class="c1"># take maximum</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">profit1</span><span class="p">,</span> <span class="n">profit2</span><span class="p">)</span>

    <span class="c1"># maximum profit will be at the bottom-right corner.</span>
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">capacity</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">solve_knapsack</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">16</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">5</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">solve_knapsack</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">16</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">6</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">solve_knapsack</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">16</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">7</span><span class="p">))</span>


<span class="n">main</span><span class="p">()</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Time and Space complexity</span>
<span class="sd">The above solution has the time and space complexity of O(N*C), where ‘N’ represents total items and ‘C’ is the maximum capacity.</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="k">def</span> <span class="nf">solve_knapsack</span><span class="p">(</span><span class="n">profits</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">capacity</span><span class="p">):</span>
    <span class="c1"># basic checks</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">profits</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">capacity</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">capacity</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="c1"># if we have only one weight, we will take it if it is not more than the capacity</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">capacity</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="p">:</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">profits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># process all sub-arrays for all the capacities</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">capacity</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">profit1</span><span class="p">,</span> <span class="n">profit2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
            <span class="c1"># include the item, if it is not more than the capacity</span>
            <span class="k">if</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="p">:</span>
                <span class="n">profit1</span> <span class="o">=</span> <span class="n">profits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">c</span> <span class="o">-</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="c1"># exclude the item</span>
            <span class="n">profit2</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="c1"># take maximum</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">profit1</span><span class="p">,</span> <span class="n">profit2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">capacity</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total knapsack profit: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">solve_knapsack</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">16</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">7</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total knapsack profit: &quot;</span> <span class="o">+</span>
          <span class="nb">str</span><span class="p">(</span><span class="n">solve_knapsack</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">16</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">6</span><span class="p">)))</span>


<span class="n">main</span><span class="p">()</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Time and Space complexity</span>
<span class="sd">The above solution the has time and space complexity of O(N*S),</span>
<span class="sd">where ‘N’ represents total numbers and ‘S’ is the total sum of all the numbers.</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="equal-subset-sum-partition-medium">
<h1><span class="section-number">15.2. </span>Equal Subset Sum Partition (medium)<a class="headerlink" href="#equal-subset-sum-partition-medium" title="Permalink to this headline">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Problem Statement</span>
<span class="sd">Given a set of positive numbers, find if we can partition it into two subsets such that the sum of elements in both subsets is equal.</span>
<span class="sd">Example 1:</span>
<span class="sd">Input: {1, 2, 3, 4}</span>
<span class="sd">Output: True</span>
<span class="sd">Explanation: The given set can be partitioned into two subsets with equal sum: {1, 4} &amp; {2, 3}</span>
<span class="sd">Example 2:</span>
<span class="sd">Input: {1, 1, 3, 4, 7}</span>
<span class="sd">Output: True</span>
<span class="sd">Explanation: The given set can be partitioned into two subsets with equal sum: {1, 3, 4} &amp; {1, 7}</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="c1"># my Top-down code</span>
<span class="k">def</span> <span class="nf">can_partition</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="c1"># TODO: Write your code here</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">s</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">))]</span>
    <span class="k">return</span> <span class="n">can_partition_recursive</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">can_partition_recursive</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">currentIndex</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">sum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">currentIndex</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">][</span><span class="nb">sum</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">][</span><span class="nb">sum</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">num</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nb">sum</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">can_partition_recursive</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="nb">sum</span> <span class="o">-</span> <span class="n">num</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">],</span>
                                   <span class="n">currentIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">][</span><span class="nb">sum</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">][</span><span class="nb">sum</span><span class="p">]</span>

    <span class="n">dp</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">][</span><span class="nb">sum</span><span class="p">]</span> <span class="o">=</span> <span class="n">can_partition_recursive</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span>
                                                    <span class="n">currentIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">][</span><span class="nb">sum</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">])))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">])))</span>


<span class="n">main</span><span class="p">()</span>


<span class="c1"># my bottom-up code</span>
<span class="k">def</span> <span class="nf">can_partition</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="c1"># TODO: Write your code here</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">s</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">))]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">)):</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
            <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">w1</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">n</span> <span class="o">-</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">w2</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="p">]</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">w2</span> <span class="ow">or</span> <span class="n">w1</span>

    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">])))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">])))</span>


<span class="n">main</span><span class="p">()</span>


<span class="c1"># my bottom-up code with O(len(num)) space complexity</span>
<span class="k">def</span> <span class="nf">can_partition</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="c1"># TODO: Write your code here</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">s</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">w1</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">w2</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">w1</span> <span class="ow">or</span> <span class="n">w2</span>

    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">])))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">])))</span>


<span class="n">main</span><span class="p">()</span>


<span class="c1"># Basic Solution</span>
<span class="k">def</span> <span class="nf">can_partition</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="c1"># if &#39;s&#39; is a an odd number, we can&#39;t have two subsets with equal sum</span>
    <span class="k">if</span> <span class="n">s</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">can_partition_recursive</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">s</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">can_partition_recursive</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">currentIndex</span><span class="p">):</span>
    <span class="c1"># base check</span>
    <span class="k">if</span> <span class="nb">sum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">currentIndex</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># recursive call after choosing the number at the `currentIndex`</span>
    <span class="c1"># if the number at `currentIndex` exceeds the sum, we shouldn&#39;t process this</span>
    <span class="k">if</span> <span class="n">num</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nb">sum</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">can_partition_recursive</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">sum</span> <span class="o">-</span> <span class="n">num</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">],</span>
                                    <span class="n">currentIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># recursive call after excluding the number at the &#39;currentIndex&#39;</span>
    <span class="k">return</span> <span class="n">can_partition_recursive</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">currentIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">])))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">])))</span>


<span class="n">main</span><span class="p">()</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Time and Space complexity</span>
<span class="sd">The time complexity of the above algorithm is exponential O(2^n), where ‘n’ represents the total number.</span>
<span class="sd">The space complexity is O(n), which will be used to store the recursion stack.</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="c1"># Top-down Dynamic Programming with Memorization</span>
<span class="k">def</span> <span class="nf">can_partition</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

    <span class="c1"># if &#39;s&#39; is a an odd number, we can&#39;t have two subsets with equal sum</span>
    <span class="k">if</span> <span class="n">s</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># initialize the &#39;dp&#39; array, -1 for default, 1 for true and 0 for false</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">))]</span>
    <span class="k">return</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">can_partition_recursive</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span> <span class="o">/</span>
                                                        <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">can_partition_recursive</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">currentIndex</span><span class="p">):</span>
    <span class="c1"># base check</span>
    <span class="k">if</span> <span class="nb">sum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">currentIndex</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="c1"># if we have not already processed a similar problem</span>
    <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">][</span><span class="nb">sum</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="c1"># recursive call after choosing the number at the currentIndex</span>
        <span class="c1"># if the number at currentIndex exceeds the sum, we shouldn&#39;t process this</span>
        <span class="k">if</span> <span class="n">num</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nb">sum</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">can_partition_recursive</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="nb">sum</span> <span class="o">-</span> <span class="n">num</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">],</span>
                                       <span class="n">currentIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">][</span><span class="nb">sum</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">return</span> <span class="mi">1</span>

        <span class="c1"># recursive call after excluding the number at the currentIndex</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">][</span><span class="nb">sum</span><span class="p">]</span> <span class="o">=</span> <span class="n">can_partition_recursive</span><span class="p">(</span>
            <span class="n">dp</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">currentIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">][</span><span class="nb">sum</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">])))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">])))</span>


<span class="n">main</span><span class="p">()</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Time and Space complexity</span>
<span class="sd">The above algorithm has the time and space complexity of O(N*S),</span>
<span class="sd">where ‘N’ represents total numbers and ‘S’ is the total sum of all the numbers.</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="c1"># Bottom-up Dynamic Programming</span>
<span class="k">def</span> <span class="nf">can_partition</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

    <span class="c1"># if &#39;s&#39; is a an odd number, we can&#39;t have two subsets with same total</span>
    <span class="k">if</span> <span class="n">s</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># we are trying to find a subset of given numbers that has a total sum of &#39;s/2&#39;.</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="c1"># populate the s=0 columns, as we can always for &#39;0&#39; sum with an empty set</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># with only one number, we can form a subset only when the required sum is</span>
    <span class="c1"># equal to its value</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span>

    <span class="c1"># process all subsets for all sums</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># if we can get the sum &#39;j&#39; without the number at index &#39;i&#39;</span>
            <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">num</span><span class="p">[</span>
                    <span class="n">i</span><span class="p">]:</span>  <span class="c1"># else if we can find a subset to get the remaining sum</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

    <span class="c1"># the bottom-right corner will have our answer.</span>
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">s</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">])))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">])))</span>


<span class="n">main</span><span class="p">()</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Time and Space complexity</span>
<span class="sd">The above solution the has time and space complexity of O(N*S),</span>
<span class="sd">where ‘N’ represents total numbers and ‘S’ is the total sum of all the numbers.</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="subset-sum-medium">
<h1><span class="section-number">15.3. </span>Subset Sum (medium)<a class="headerlink" href="#subset-sum-medium" title="Permalink to this headline">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Problem Statement</span>
<span class="sd">Given a set of positive numbers, determine if a subset exists whose sum is equal to a given number ‘S’.</span>
<span class="sd">Example 1:</span>
<span class="sd">Input: {1, 2, 3, 7}, S=6</span>
<span class="sd">Output: True</span>
<span class="sd">The given set has a subset whose sum is &#39;6&#39;: {1, 2, 3}</span>
<span class="sd">Example 2:</span>
<span class="sd">Input: {1, 2, 7, 1, 5}, S=10</span>
<span class="sd">Output: True</span>
<span class="sd">The given set has a subset whose sum is &#39;10&#39;: {1, 2, 7}</span>
<span class="sd">Example 3:</span>
<span class="sd">Input: {1, 3, 4, 8}, S=6</span>
<span class="sd">Output: False</span>
<span class="sd">The given set does not have any subset whose sum is equal to &#39;6&#39;.</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="k">def</span> <span class="nf">can_partition</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">sum</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">sum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="c1"># handle sum=0, as we can always have &#39;0&#39; sum with an empty set</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># with only one number, we can have a subset only when the required sum is equal to its value</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">sum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span>

    <span class="c1"># process all subsets for all sums</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">sum</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1"># if dp[s]==true, this means we can get the sum &#39;s&#39; without num[i], hence we can move on to</span>
            <span class="c1"># the next number else we can include num[i] and see if we can find a subset to get the</span>
            <span class="c1"># remaining sum</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dp</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="ow">and</span> <span class="n">s</span> <span class="o">&gt;=</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">s</span> <span class="o">-</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="nb">sum</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="mi">6</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">10</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="mi">6</span><span class="p">)))</span>


<span class="n">main</span><span class="p">()</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Time and Space complexity</span>
<span class="sd">The above solution has the time and space complexity of O(N*S), where ‘N’ represents total numbers and ‘S’ is the required sum.</span>
<span class="sd">Challenge</span>
<span class="sd">Can we improve our bottom-up DP solution even further? Can you find an algorithm that has O(S) space complexity?</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="minimum-subset-sum-difference-hard">
<h1><span class="section-number">15.4. </span>Minimum Subset Sum Difference (hard)<a class="headerlink" href="#minimum-subset-sum-difference-hard" title="Permalink to this headline">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Problem Statement</span>
<span class="sd">Given a set of positive numbers, partition the set into two subsets with minimum difference between their subset sums.</span>
<span class="sd">Example 1:</span>
<span class="sd">Input: {1, 2, 3, 9}</span>
<span class="sd">Output: 3</span>
<span class="sd">Explanation: We can partition the given set into two subsets where minimum absolute difference</span>
<span class="sd">between the sum of numbers is &#39;3&#39;. Following are the two subsets: {1, 2, 3} &amp; {9}.</span>
<span class="sd">Example 2:</span>
<span class="sd">Input: {1, 2, 7, 1, 5}</span>
<span class="sd">Output: 0</span>
<span class="sd">Explanation: We can partition the given set into two subsets where minimum absolute difference</span>
<span class="sd">between the sum of number is &#39;0&#39;. Following are the two subsets: {1, 2, 5} &amp; {7, 1}.</span>
<span class="sd">Example 3:</span>
<span class="sd">Input: {1, 3, 100, 4}</span>
<span class="sd">Output: 92</span>
<span class="sd">Explanation: We can partition the given set into two subsets where minimum absolute difference</span>
<span class="sd">between the sum of numbers is &#39;92&#39;. Here are the two subsets: {1, 3, 4} &amp; {100}.</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="c1"># Basic Solution</span>
<span class="k">def</span> <span class="nf">can_partition</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">can_partition_recursive</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">can_partition_recursive</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">currentIndex</span><span class="p">,</span> <span class="n">sum1</span><span class="p">,</span> <span class="n">sum2</span><span class="p">):</span>
    <span class="c1"># base check</span>
    <span class="k">if</span> <span class="n">currentIndex</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sum1</span> <span class="o">-</span> <span class="n">sum2</span><span class="p">)</span>

    <span class="c1"># recursive call after including the number at the currentIndex in the first set</span>
    <span class="n">diff1</span> <span class="o">=</span> <span class="n">can_partition_recursive</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">currentIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                    <span class="n">sum1</span> <span class="o">+</span> <span class="n">num</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">],</span> <span class="n">sum2</span><span class="p">)</span>

    <span class="c1"># recursive call after including the number at the currentIndex in the second set</span>
    <span class="n">diff2</span> <span class="o">=</span> <span class="n">can_partition_recursive</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">currentIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sum1</span><span class="p">,</span>
                                    <span class="n">sum2</span> <span class="o">+</span> <span class="n">num</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">])</span>

    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">diff1</span><span class="p">,</span> <span class="n">diff2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">])))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">])))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">4</span><span class="p">])))</span>


<span class="n">main</span><span class="p">()</span>


<span class="c1"># Top-down Dynamic Programming with Memoization</span>
<span class="k">def</span> <span class="nf">can_partition</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">))]</span>
    <span class="k">return</span> <span class="n">can_partition_recursive</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">can_partition_recursive</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">currentIndex</span><span class="p">,</span> <span class="n">sum1</span><span class="p">,</span> <span class="n">sum2</span><span class="p">):</span>
    <span class="c1"># base check</span>
    <span class="k">if</span> <span class="n">currentIndex</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sum1</span> <span class="o">-</span> <span class="n">sum2</span><span class="p">)</span>

    <span class="c1"># check if we have not already processed similar problem</span>
    <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">][</span><span class="n">sum1</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="c1"># recursive call after including the number at the currentIndex in the first set</span>
        <span class="n">diff1</span> <span class="o">=</span> <span class="n">can_partition_recursive</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">currentIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                        <span class="n">sum1</span> <span class="o">+</span> <span class="n">num</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">],</span> <span class="n">sum2</span><span class="p">)</span>

        <span class="c1"># recursive call after including the number at the currentIndex in the second set</span>
        <span class="n">diff2</span> <span class="o">=</span> <span class="n">can_partition_recursive</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">currentIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sum1</span><span class="p">,</span>
                                        <span class="n">sum2</span> <span class="o">+</span> <span class="n">num</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">])</span>

        <span class="n">dp</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">][</span><span class="n">sum1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">diff1</span><span class="p">,</span> <span class="n">diff2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">][</span><span class="n">sum1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">])))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">])))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">4</span><span class="p">])))</span>


<span class="n">main</span><span class="p">()</span>


<span class="c1"># Bottom-up Dynamic Programming</span>
<span class="k">def</span> <span class="nf">can_partition</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="c1"># populate the s=0 columns, as we can always form &#39;0&#39; sum with an empty set</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># with only one number, we can form a subset only when the required sum is equal to that number</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span>

    <span class="c1"># process all subsets for all sums</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># if we can get the sum &#39;s&#39; without the number at index &#39;i&#39;</span>
            <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="c1"># else include the number and see if we can find a subset to get the remaining sum</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

    <span class="n">sum1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># find the largest index in the last row which is true</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">sum1</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">break</span>

    <span class="n">sum2</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-</span> <span class="n">sum1</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sum2</span> <span class="o">-</span> <span class="n">sum1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">])))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">])))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can partition: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">can_partition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">4</span><span class="p">])))</span>


<span class="n">main</span><span class="p">()</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Time and Space complexity</span>
<span class="sd">The above solution has the time and space complexity of O(N*S),</span>
<span class="sd">where ‘N’ represents total numbers and ‘S’ is the total sum of all the numbers.</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="problem-challenge-1-count-of-subset-sum-hard">
<h1><span class="section-number">15.5. </span>Problem Challenge 1 - Count of Subset Sum (hard)<a class="headerlink" href="#problem-challenge-1-count-of-subset-sum-hard" title="Permalink to this headline">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Problem Challenge 1</span>
<span class="sd">Count of Subset Sum (hard)</span>
<span class="sd">Given a set of positive numbers, find the total number of subsets whose sum is equal to a given number ‘S’.</span>
<span class="sd">Example 1: #</span>
<span class="sd">Input: {1, 1, 2, 3}, S=4</span>
<span class="sd">Output: 3</span>
<span class="sd">The given set has &#39;3&#39; subsets whose sum is &#39;4&#39;: {1, 1, 2}, {1, 3}, {1, 3}</span>
<span class="sd">Note that we have two similar sets {1, 3}, because we have two &#39;1&#39; in our input.</span>
<span class="sd">Example 2: #</span>
<span class="sd">Input: {1, 2, 7, 1, 5}, S=9</span>
<span class="sd">Output: 3</span>
<span class="sd">The given set has &#39;3&#39; subsets whose sum is &#39;9&#39;: {2, 7}, {1, 7, 1}, {1, 2, 1, 5}</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="k">def</span> <span class="nf">count_subsets</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">sum</span><span class="p">):</span>
    <span class="c1">#TODO: Write - Your - Code</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">sum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">))]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">)):</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">sum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">sum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="nb">sum</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total number of subsets &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">count_subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total number of subsets: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">count_subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">9</span><span class="p">)))</span>


<span class="n">main</span><span class="p">()</span>


<span class="c1"># Basic Solution</span>
<span class="k">def</span> <span class="nf">count_subsets</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">sum</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">count_subsets_recursive</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">count_subsets_recursive</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">currentIndex</span><span class="p">):</span>
    <span class="c1"># base checks</span>
    <span class="k">if</span> <span class="nb">sum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">currentIndex</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="c1"># recursive call after selecting the number at the currentIndex</span>
    <span class="c1"># if the number at currentIndex exceeds the sum, we shouldn&#39;t process this</span>
    <span class="n">sum1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">num</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nb">sum</span><span class="p">:</span>
        <span class="n">sum1</span> <span class="o">=</span> <span class="n">count_subsets_recursive</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">sum</span> <span class="o">-</span> <span class="n">num</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">],</span>
                                       <span class="n">currentIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># recursive call after excluding the number at the currentIndex</span>
    <span class="n">sum2</span> <span class="o">=</span> <span class="n">count_subsets_recursive</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">currentIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sum1</span> <span class="o">+</span> <span class="n">sum2</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total number of subsets &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">count_subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total number of subsets: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">count_subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">9</span><span class="p">)))</span>


<span class="n">main</span><span class="p">()</span>


<span class="c1"># Top-down Dynamic Programming with Memorization</span>
<span class="k">def</span> <span class="nf">count_subsets</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">sum</span><span class="p">):</span>
    <span class="c1"># create a two dimensional array for Memoization, each element is initialized to &#39;-1&#39;</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">sum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">))]</span>
    <span class="k">return</span> <span class="n">count_subsets_recursive</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">count_subsets_recursive</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">currentIndex</span><span class="p">):</span>
    <span class="c1"># base checks</span>
    <span class="k">if</span> <span class="nb">sum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">currentIndex</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="c1"># check if we have not already processed a similar problem</span>
    <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">][</span><span class="nb">sum</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="c1"># recursive call after choosing the number at the currentIndex</span>
        <span class="c1"># if the number at currentIndex exceeds the sum, we shouldn&#39;t process this</span>
        <span class="n">sum1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">num</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nb">sum</span><span class="p">:</span>
            <span class="n">sum1</span> <span class="o">=</span> <span class="n">count_subsets_recursive</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="nb">sum</span> <span class="o">-</span> <span class="n">num</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">],</span>
                                           <span class="n">currentIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># recursive call after excluding the number at the currentIndex</span>
        <span class="n">sum2</span> <span class="o">=</span> <span class="n">count_subsets_recursive</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">currentIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">dp</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">][</span><span class="nb">sum</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum1</span> <span class="o">+</span> <span class="n">sum2</span>

    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">][</span><span class="nb">sum</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total number of subsets &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">count_subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total number of subsets: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">count_subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">9</span><span class="p">)))</span>


<span class="n">main</span><span class="p">()</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Time and Space complexity</span>
<span class="sd">The above solution has the time and space complexity of O(N*S),</span>
<span class="sd">where ‘N’ represents total numbers and ‘S’ is the desired sum.</span>
<span class="sd">Challenge</span>
<span class="sd">Can we improve our bottom-up DP solution even further? Can you find an algorithm that has O(S) space complexity?</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="c1"># Bottom-up Dynamic Programming</span>
<span class="k">def</span> <span class="nf">count_subsets</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">sum</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">sum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="c1"># populate the sum = 0 columns, as we will always have an empty set for zero sum</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># with only one number, we can form a subset only when the required sum is</span>
    <span class="c1"># equal to its value</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">sum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="c1"># process all subsets for all sums</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">sum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># exclude the number</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">s</span><span class="p">]</span>
            <span class="c1"># include the number, if it does not exceed the sum</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">&gt;=</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">s</span> <span class="o">-</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

    <span class="c1"># the bottom-right corner will have our answer.</span>
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="nb">sum</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total number of subsets &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">count_subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total number of subsets: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">count_subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">9</span><span class="p">)))</span>


<span class="n">main</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">count_subsets</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">sum</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">sum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># with only one number, we can form a subset only when the required sum is equal to the number</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">sum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="c1"># process all subsets for all sums</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">sum</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">&gt;=</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">s</span> <span class="o">-</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="nb">sum</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total number of subsets &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">count_subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total number of subsets: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">count_subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">9</span><span class="p">)))</span>


<span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="problem-challenge-2-target-sum-hard">
<h1><span class="section-number">15.6. </span>Problem Challenge 2 - Target Sum (hard)<a class="headerlink" href="#problem-challenge-2-target-sum-hard" title="Permalink to this headline">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Problem Challenge 2</span>
<span class="sd">Target Sum (hard)</span>
<span class="sd">You are given a set of positive numbers and a target sum ‘S’. Each number should be assigned either a ‘+’ or ‘-’ sign.</span>
<span class="sd">We need to find the total ways to assign symbols to make the sum of the numbers equal to the target ‘S’.</span>
<span class="sd">Example 1:</span>
<span class="sd">Input: {1, 1, 2, 3}, S=1</span>
<span class="sd">Output: 3</span>
<span class="sd">Explanation: The given set has &#39;3&#39; ways to make a sum of &#39;1&#39;: {+1-1-2+3} &amp; {-1+1-2+3} &amp; {+1+1+2-3}</span>
<span class="sd">Example 2:</span>
<span class="sd">Input: {1, 2, 7, 1}, S=9</span>
<span class="sd">Output: 2</span>
<span class="sd">Explanation: The given set has &#39;2&#39; ways to make a sum of &#39;9&#39;: {+1+2+7-1} &amp; {-1+2+7+1}</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="c1"># mycode</span>
<span class="k">def</span> <span class="nf">find_target_subsets</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">))]</span>
    <span class="n">len_s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">-</span> <span class="n">len_s</span> <span class="o">==</span> <span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">-</span> <span class="n">len_s</span> <span class="o">==</span> <span class="o">-</span><span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">-</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">+</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">s</span> <span class="o">+</span> <span class="n">len_s</span><span class="p">]</span>


<span class="c1"># answer</span>
<span class="k">def</span> <span class="nf">find_target_subsets</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="n">totalSum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

    <span class="c1"># if &#39;s + totalSum&#39; is odd, we can&#39;t find a subset with sum equal to &#39;(s + totalSum) / 2&#39;</span>
    <span class="k">if</span> <span class="n">totalSum</span> <span class="o">&lt;</span> <span class="n">s</span> <span class="ow">or</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">totalSum</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="n">count_subsets</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">totalSum</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>


<span class="c1"># this function is exactly similar to what we have in &#39;Count of Subset Sum&#39; problem.</span>
<span class="k">def</span> <span class="nf">count_subsets</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="c1"># populate the sum = 0 columns, as we will always have an empty set for zero sum</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># with only one number, we can form a subset only when the required sum is</span>
    <span class="c1"># equal to the number</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="c1"># process all subsets for all sums</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">s</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">&gt;=</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">s</span> <span class="o">-</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

    <span class="c1"># the bottom-right corner will have our answer.</span>
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">s</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total ways: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">find_target_subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total ways: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">find_target_subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">9</span><span class="p">)))</span>


<span class="n">main</span><span class="p">()</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Time and Space complexity</span>
<span class="sd">The above solution has time and space complexity of O(N*S), where ‘N’ represents total numbers and ‘S’ is the desired sum.</span>
<span class="sd">We can further improve the solution to use only O(S) space.</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="k">def</span> <span class="nf">find_target_subsets</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="n">totalSum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

    <span class="c1"># if &#39;s + totalSum&#39; is odd, we can&#39;t find a subset with sum equal to &#39;(s +totalSum) / 2&#39;</span>
    <span class="k">if</span> <span class="n">totalSum</span> <span class="o">&lt;</span> <span class="n">s</span> <span class="ow">or</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">totalSum</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="n">count_subsets</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">totalSum</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>


<span class="c1"># this function is exactly similar to what we have in &#39;Count of Subset Sum&#39; problem</span>
<span class="k">def</span> <span class="nf">count_subsets</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">sum</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">sum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># with only one number, we can form a subset only when the required sum is equal to the number</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">sum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="c1"># process all subsets for all sums</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">sum</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">&gt;=</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">s</span> <span class="o">-</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="nb">sum</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total ways: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">find_target_subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total ways: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">find_target_subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">9</span><span class="p">)))</span>


<span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../topological_sort_graph.html" class="btn btn-neutral float-right" title="16. Topological Sort (Graph)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../0_1_knapsack_dynamic_programming.html" class="btn btn-neutral float-left" title="15. 0/1 Knapsack (Dynamic Programming)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, XiuFu Guo

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>